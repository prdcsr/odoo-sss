
from odoo import api, fields, models, _
from odoo.exceptions import UserError, ValidationError
from odoo.tools.safe_eval import safe_eval


class SaleCouponProgram(models.Model):
    _description = "Stock Equipment Program"
    _inherit = 'sale.coupon.program'

    for_sale = fields.Boolean(string='For Sale')
    for_purchase = fields.Boolean(string='For Purchase')

    @api.model
    def _filter_picking_on_mimimum_amount(self, order):
        no_effect_lines = order._get_no_effect_on_threshold_lines()
        order_amount = {
            'amount_untaxed': order.amount_untaxed - sum(line.price_subtotal for line in no_effect_lines),
            'amount_tax': order.amount_tax - sum(line.price_tax for line in no_effect_lines)
        }
        program_ids = list()
        for program in self:
            if program.reward_type != 'discount':
                # avoid the filtered
                lines = self.env['stock.move']
            else:
                lines = order.move_ids_without_package.filtered(lambda line:
                                                  line.product_id == program.discount_line_product_id or
                                                  # line.product_id == program.reward_id.discount_line_product_id or
                                                  (program.program_type == 'promotion_program' and line.is_reward_line)
                                                  )
            untaxed_amount = order_amount['amount_untaxed'] - sum(line.price_subtotal for line in lines)
            tax_amount = order_amount['amount_tax'] - sum(line.price_tax for line in lines)
            program_amount = program._compute_program_amount('rule_minimum_amount', order.currency_id)
            if program.rule_minimum_amount_tax_inclusion == 'tax_included' and program_amount <= (
                    untaxed_amount + tax_amount) or program_amount <= untaxed_amount:
                program_ids.append(program.id)

        return self.env['sale.coupon.program'].browse(program_ids)

    def _filter_picking_programs_on_products(self, order):
        """
        To get valid programs according to product list.
        i.e Buy 1 imac + get 1 ipad mini free then check 1 imac is on cart or not
        or  Buy 1 coke + get 1 coke free then check 2 cokes are on cart or not
        """
        order_lines = order.move_ids_without_package.filtered(lambda line: line.product_id) - order._get_reward_lines()
        products = order_lines.mapped('product_id')
        products_qties = dict.fromkeys(products, 0)
        for line in order_lines:
            products_qties[line.product_id] += line.product_uom_qty
        valid_program_ids = list()
        for program in self:
            if not program.rule_products_domain:
                valid_program_ids.append(program.id)
                continue
            valid_products = program._get_valid_products(products)
            if not valid_products:
                # The program can be directly discarded
                continue
            ordered_rule_products_qty = sum(products_qties[product] for product in valid_products)
            # Avoid program if 1 ordered foo on a program '1 foo, 1 free foo'
            if program.promo_applicability == 'on_current_order' and \
                    program.reward_type == 'product' and program._get_valid_products(program.reward_product_id):
                ordered_rule_products_qty -= program.reward_product_quantity
            if ordered_rule_products_qty >= program.rule_min_quantity:
                valid_program_ids.append(program.id)
        return self.browse(valid_program_ids)

    @api.model
    def _filter_picking_programs_from_common_rules(self, order, next_order=False):
        """ Return the programs if every conditions is met
            :param bool next_order: is the reward given from a previous order
        """
        programs = self
        # Minimum requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
        # if not next_order:
        #     programs = programs and programs._filter_picking_on_mimimum_amount(order)
        if not self.env.context.get("no_outdated_coupons"):
            programs = programs and programs._filter_on_validity_dates(order)
        # programs = programs and programs.filtered(
        #     lambda program: program.maximum_use_number == 0
        #                     or program.order_count < program.maximum_use_number
        #                     or program
        #                     in (order.code_promo_program_id + order.no_code_promo_program_ids)
        # )
        # programs = programs and programs._filter_programs_on_partners(order)
        # Product requirement should not be checked if the coupon got generated by a promotion program (the requirement should have only be checked to generate the coupon)
        if not next_order:
            programs = programs and programs._filter_picking_programs_on_products(order)

        # programs_curr_order = programs.filtered(lambda p: p.promo_applicability == 'on_current_order')
        # programs = programs.filtered(lambda p: p.promo_applicability == 'on_next_order')
        # if programs_curr_order:
        #     # Checking if rewards are in the SO should not be performed for rewards on_next_order
        #     programs += programs_curr_order._filter_not_ordered_reward_programs(order)
        return programs
